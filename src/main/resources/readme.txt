Java RMI

	RMI远程方法调用是计算机之间通过网络实现对象调用的一种通讯机制。
	
	RMI被设计成一种面向对象开发方式，允许程序员使用远程对象来实现通信。
	
设计模式三个分类
	创建型模式：对象实例化的模式，创建型模式解耦了对象的实例化过程
	
	结构型模式：把类或对象结合在一起形成更大的结构
	
	行为型模式：类和对象如何交互，及划分责任和算法
	
		
	各个模式的关键点
		简单工厂：一个工厂类根据传入的参量决定创建出哪一种产品类的实例
		工厂方法：定义一个创建对象的接口，让字类决定实例化哪一个类
		抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类
		单例模式：某个类只能有一个实例，提供一个全局访问点
		生成器模式：封装一个复杂对象的构建过程，并可以按步骤构造
		原型模式：通过复制现有的实例来创新新的实例
		适配器模式：将一个类的方法j接口转换成客户希望的另外一个接口
		组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构
		装饰模式：动态地给对象添加新的功能
		代理模式：为其他对象提供一个代理以控制对这个对象的访问
		蝇量模式：通过共享技术有效地支持大量细粒度的对象
		外观模式：提供统一的方法来访问子系统的一群接口
		桥接模式：将抽象部分与它的实现部分分离，使他们都可以独立的变化
		模板模式：定义一个算法结构，而将一些步骤延迟到子类中实现
		解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器
		策略模式：定义一系列的算法，把他们封装起来，并且使它们可相互替换
		状态模式：允许一个对象在其内部状态改变时改变它的行为
		观测者模式：对象间的一对多的依赖关系
		备忘录模式：在不破坏封装性的前提下，保存对象的内部状态
		中介者模式：用一个中介对象来封装一系列的对象交互
		命令模式：将命令请求封装为一个对象，使得可用不同的请求来进行参数化
		访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素新的功能
		责任链：请求发送者和接收者之间解耦，使得多个对象都有机会处理这个请求
		迭代器：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构
		
对象设计六大原则


设计模式用途和优点
	目的：是软件工程在维护性、扩展性、变化性、复杂度方面成O(N)
	OO 是原则，设计模式是具体方法、工具

用模式来思考
	保持简单
		尽可能用最简单的方式解决问题
		简单而弹性的设计，一般使用模式是最好的方法
		
		
	设计模式并非万能
		模式是通用问题的经验总结
		使用模式时要考虑它对其他部分的影响
		不需要预留任何弹性的时候，删除掉模式
		平衡和妥协
	
	何时需要模式
		找出设计中会变化的部分，通常就是需要考虑模式的地方
		重构时
		重构就是改变代码来改进组织方式的过程
		利用模式来重构

简单工厂模式
	属于类的创建型模式，又叫做静态工厂模式。通过专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。
	
工厂方法模式
	属于类的创建型模式，又叫做多态工厂模式。定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。

抽象工厂模式
	抽象工厂角色：抽象工厂模式的核心，包含多个产品结构的声明，任何工厂类必须实现这个接口
	具体工厂角色：具体工厂类是抽象工厂的一个实现，负责实例化某个产品族中的产品对象
	抽象角色：抽象模式所创建所有对象的父类，它负责描述所有实例所共有的公共接口
	具体产品角色：抽象模式所创建的具体实例对象
	
单例模式
	属于类的创建型模式，保证一个类只有一个实例存在，同时提供能对该实例加以访问全局访问的方法
	饿汉式
	懒汉式
	双重检查
	
原型模式
	由原型对象自身创建目标对象
	目标对象是原型对象的一个克隆
	根据对象克隆深度层次的不同，有浅度克隆和深度克隆。
	
	应用场景
		在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。
		希望对目标对象的修改不影响既有的原型对象
		隐藏克隆操作的细节。

建造者模式
	属于类的创建型模式，用来隐藏复合对象的创建过程，它把复合对象的创建过程加以抽象，通过子类继承和重载的方式，动态地创建具有复合属性的对象。
	
装饰模式
	又叫做包装模式。通过一种对客户端透明的方式来扩展对象的功能，是继承关系的一个替换方案。
	
策略模式
	Strategy模式是对一系列的算法进行封装，为所有算法定义一个抽象的算法接口，
	并通过继承该抽象算法接口为所有算法加以封装和实现，具体算法选择交由客户端决定(策略).

	Strategy 
		策略(算法)抽象
		
	ConcreteStrategy
		各种策略(算法)的具体实现
		
	Context
		策略的外部封装类，或者说策略的容器类。根据不同策略执行不同的行为。
		策略由外部环境决定。
	
	优点
		1、提供相关的算法族的办法。恰当使用继承可以把公共的代码移到父类里面，从而避免重复的代码。
		2、避免使用多重条件转移语句
		3、可以替换继承关系的办法
		
	策略模式只适用客户端知道所有的算法或行为的情况，会造成很多策略类。
		
	注意点
		分析项目中变化的部分与不变的部分
		多用组合少用继承；用行为类组合，而不是行为的继承。更有弹性

观察者模式
	行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态。
	提供关联对象一种同步通信的手段，使某个对象与依赖他的其他对象之间保持状态同步。
	
	典型应用
		侦听事件驱动程序设计中的外部事件
		侦听/监听某个对象的状态变化
		发布者/订阅者模型，当一个外部事件被触发时，通知订阅者 

享元模式
	构造型模式之一，它通过与其他类似对象共享数据来减小内存占用。
	
	抽象享元角色：所有具体享元类的父类，规定一些需要实现的公共接口。
	具体享元角色：抽象享元角色的具体实现类，并实现了抽象享元角色规定的方法。
	享元工厂角色：负责创建和管理享元角色。
	
代理模式
	虚拟代理
		创建开销大的对象提供代理服务。真正的对象在创建前和创建中时，由虚拟代理来扮演替身。
	动态代理
		运行时动态创建代理类对象，并将方法调用转发到指定类。
	保护代理
		
	几种变体
		防火墙代理
		缓存代理
		智能引用代理
		同步代理
		写入时复制代理
		
	构造型模式之一，它可以为其他对象提供一种代理以控制对这个对象的访问。
	
	所谓代理是指具有与代理元（被代理对象）具有相同的接口的类，客户端必须通过
	代理与被代理的目标类交互，而代理一般在交互的过程中，进行某些特别的处理。
	
	动态代理
		1、InvocationHandler接口
		2、invoke方法
		3、Proxy.newProxyInstance();
	
外观模式
	为一组具有类似功能的类群，比如类库，子系统等等，提供一个一致的简单界面。
	
组合模式
	构造型的设计模式。通过递归手段来构造树形的对象结构，并可以通过一个对象来访问整个对象树。
	
桥接模式
	构造型的设计模式。基于类的最小设计原则，通过封装，聚合以及继承等行为来让不同的类
	承担不同的责任。主要特点是把抽象与行为实现分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。
	
适配器模式
	构造型的设计模式
	
	通过Adapter模式可以改变已有类(或外部类)的接口类
	
解释器模式
	行为模式，它是特殊的设计模式，它建立一个解释器，对于特定的计算机程序设计语言，
	用来解释预先定义的方法。简单来说，Interpreter模式是一种简单的语法解释器构架。
		
中介者模式
	行为模式，在Mediator模式中，类之间的交互行为被统一放在Mediator的对象中，对象通过Mediator对象同其他对象交互，
	Mediator对象起着控制器的作用。	
	
	1、将系统按功能分割成更小的对象，符合类的最小设计原则
	2、对关联对象的集中控制
	3、减小类的耦合程度，明确类之间的相互关系。
	4、有利于提高类的重用性
			
职责链模式
   行为模式，该模式构造一系列分别担当不同的职责的类的对象来共同完成一个任务
   
 优点：
 	1、责任的分组。每个类只需要处理自己该处理的工作(不该处理的传递给下一个对象完成)，明确各类的责任范围
 	符合类的最小封装原则
 	2、可以根据需要自由组合工作流程
 	3、类与类之间可以以松耦合的形式加以组织
 缺点：
 	因为处理时以链的形式在对象间传递消息，根据实现方式不同，有可能会影响处理的速度
 
迭代模式
	行为模式，它把对容器中包含的内部对象的访问委让给外部类，使用Iterator按顺序进行遍历访问的设计模式。
	
	应用场景
		访问容器中包含的内部对象
		按顺序访问
		
	优点
		实现功能分离，简化容器接口。让容器只实现本身的基本功能，把迭代功能委让给外部类实现，符合类的设计原则
		隐藏容器的实现细节
		为容器或其子容器提供一个统一接口
		可以为容器或其子容器实现不容的迭代方法或多个迭代方法
		
模板方法模式
	行为模式，具有特定步骤算法中的某些必要的处理委让给抽象方法，通过子类继承对抽象方法的不同实现改变整个算法 的行为。
	
	应用场景
		具有统一的操作步骤或操作过程
		具有不同的操作细节
		存在多个具有相同操作步骤的应用场景，但是某些具体的操作细节却各不相同
		
备忘录模式
	在不破坏封装的前提下，存储关键对象的重要状态，从而可以在将来把对象还原到存储的那个状态
	
	优点：
		状态存储在外面，不和关键对象混在一起，这可以帮助维护内聚
		提供了容易实现的恢复能力
		保持了关键对象的数据封装
	缺点：
		资源消耗上面备忘录对象会很昂贵
		存储和恢复状态的过程比较耗时
		
	适用场景
		必须保存一个对象在某一个时刻(整体或者部分)状态，在对象以外的地方，以后需要时恢复到先前的状态时
		
	注意事项
		注意开销	
		
状态模式
	行为模式。state模式允许通过改变对象的内部状态而改变对象的行为
	
命令模式
	行为模式，Command的类封装了对目标对象的调用行为以及调用参数。
	
	应用场景
		调用前后需要对调用参数进行某些处理
		调用前后需要进行某些额外处理，比如日志，缓存，记录历史操作等
		
访问者模式
	行为模式，分离对象的数据和行为，可以不修改已有类的情况下，增加新的操作。
	
	
开放封闭原则
	面对需求的改变而保持系统的相对稳定，从而使得系统可以很容易的从一个版本升级到另一个版本。
	
单一职责原则
	就一个类而言，应该仅有一个引起它变化的原因。
里式代换原则
	一个软件实体如果使用的是一个子类的话，那么它不能适用于其父类
	
依赖倒转原则
	抽象不应该依赖于细节，细节应该依赖于抽象
	高层模块不依赖与底层模块，两者都依赖抽象
	
	
迪米特法则	
	最少知识原则，也就说，一个对象应当对其他对象尽可能少的了解。
	